# 安装
- 仅支持IE8（不含）以上的浏览器，因为使用了ECMAScript 5的特性。
- 有两种构建方式，独立构建和运行构建。它们的区别在于前者包含模板编译器而后者不包含。模板编译器的职责是将模板字符串编译为纯 JavaScript 的渲染函数。如果你想要在组件中使用 template 选项，你就需要编译器。
- 独立构建包含模板编译器并支持 template 选项。 它也依赖于浏览器的接口的存在，所以你不能使用它来为服务器端渲染。
- 运行时构建不包含模板编译器，因此不支持 template 选项，只能用 render 选项，但即使使用运行时构建，在单文件组件中也依然可以写模板，因为单文件组件的模板会在构建时预编译为 render 函数。运行时构建比独立构建要轻量30%。默认 NPM 包导出的是 运行时 构建。
- 运行时构建的是完全兼容 CSP（内容安全策略）的；独立的构建取决于该功能编译模板，所以无法使用这些环境。
- UMD版：可以在浏览器中直接通过script标签引用；CommonJS版：供老版本的模块打包器（browserify或webpack 1）使用；ES Module版：供现代化的模块打包器使用（Webpack 2或Gulp）。

# 介绍
- Vue 还提供了 v-model 指令，它能轻松实现表单输入和应用状态之间的双向绑定。


# Vue实例
- 每个 Vue.js 应用都是通过构造函数 Vue 创建一个 Vue 的根实例 启动的。
- 不要在实例属性或者回调函数中（如 vm.$watch('a', newVal => this.myMethod())）使用箭头函数。
- 实例的生命周期：beforeCreate、created、beforeMount、mounted、beforeUpdate、updated、beforeDestroy、destroyed。

# 模板语法

# 计算属性与监视器
- 计算属性会根据他们所依赖的属性进行缓存，而方法则是每次都会执行运算。
- computed getter、setter。
- watch监视器在进行异步或者是耗时操作的时候会很有用。

# Class与Style绑定
- 对象、数组扩展。
- 组件的class会作用域组件的根节点，并且不会覆盖根节点原有的class。
- 内联样式：对象、数组、自动前缀、多个值。

# 条件渲染
- 但是如果我们想切换多个元素呢？此时我们可以把一个 template 元素当做包装元素，并在上面使用 v-if。最终的渲染结果不会包含 template 元素。
- v-show指令：总是被渲染并保存在DOM中，不可与 template 、v-else 同用。
- v-if 是“真正的”条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。
- v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。
- 相比之下， v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。
- 一般来说， v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件不太可能改变，则使用 v-if 较好。

# 列表渲染
- v-for的优先级高于v-if。

# 事件处理器
- v-on:click="handlerName/handlerName(args)"，即可以是处理函数名，也可以直接调用处理函数（内联处理函数）。
- 事件修饰符：.stop, .prevent, .capture, .self, .once
- 只有once修饰符可以同时使用在原生DOM事件和Vue组件事件上，其他的只能作用在原生DOM事件上。
- 按键修饰符、修饰按键、鼠标按键修饰符。
- Vue这样在DOM上添加事件监听的做法违背了关注点分离的传统观念？不会。所有的 Vue.js 事件处理方法和表达式都严格绑定在当前视图的 ViewModel 上，它不会导致任何维护上的困难。
- 使用 v-on 有几个好处：
    * 扫一眼 HTML 模板便能轻松定位在 JavaScript 代码里对应的方法。
    * 因为你无须在 JavaScript 里手动绑定事件，你的 ViewModel 代码可以是非常纯粹的逻辑，和 DOM 完全解耦，更易于测试。
    * 当一个 ViewModel 被销毁时，所有的事件处理器都会自动被删除。你无须担心如何自己清理它们。

# 表单控件绑定
- v-model并不会在 IME（比如：中文、日文） 构成中得到更新，除非自己使用input事件。
- 修饰符：
    * .lazy：在默认情况下， v-model 在 input 事件中同步输入框的值与数据 (除了 上述 IME 部分)，但你可以添加一个修饰符 lazy ，从而转变为在 change 事件中同步。
    * .number：自动将用户的输入值转为 Number 类型。
    * .trim：自动过滤用户输入的首尾空格。

# 组件
- 要注册一个全局组件，可以使用 Vue.component(tagName, options)。
- 要确保在初始化根实例 之前 注册了组件。
- 不必在全局注册每个组件。通过使用组件实例选项注册，可以使组件仅在另一个实例/组件的作用域中可用。
- is属性
- data必须是函数。
- 构成组件：父子组件的关系可以总结为 props down, events up。
- 当使用的不是字符串模版，camelCased (驼峰式) 命名的 prop 需要转换为相对应的 kebab-case (短横线隔开式) 命名。
- 如果想传递一个实际的number，需要使用 v-bind。
- 单向数据流：每次父组件更新时，子组件的所有 prop 都会更新为最新值；不应该在子组件内部改变 prop。
- props属性的两个作用：
	* prop 作为初始值传入后，子组件想把它当作局部数据来用；
	* prop 作为初始值传入，由子组件处理成其它数据输出。
- 正确的使用方式是：
	* 定义一个局部变量（data），并用 prop 的值初始化它；
	* 定义一个计算属性（computed），处理 prop 的值并返回。
- 注意在 JavaScript 中对象和数组是引用类型，指向同一个内存空间，如果 prop 是一个对象或数组，在子组件内部改变它会影响父组件的状态。
- prop验证。
- 每个 Vue 实例都实现了事件接口(Events interface)，即可以使用 $on(eventName) 监听事件；可以使用 $emit(eventName) 触发事件。
- 你可能想在某个组件的根元素上监听一个原生事件。可以使用 .native 修饰 v-on 。
- 在2.0版本中移除了.sync（双向绑定），但在2.3版本中又重新加回来了，只不过只是一个事件监听的语法糖，在子组件中改变父组件状态的代码需要更加容易被区分。

```javascript
// 在父组件中
<comp :foo.sync="bar"></comp>

// 在子组件中
this.$emit('update:foo', newValue)
```
- 使用 v-model 来进行数据双向绑定，只不过是语法糖。
- 要让自定义组件的 v-model 生效，它必须：接受一个 value 属性；在有新的 value 时触发 input 事件。
- 定制组件模型：像在checkboxes或radio中，value可能还有其他的用途，可以设置model选项来避免冲突。
- 非父子组件通信：简单情况下可以使用一个空的Vue实例作为中央事件总线；复杂的情况下需要使用专门的状态管理模式（例如：类Flux的Vuex）。
- 父组件模板的内容在父组件作用域内编译；子组件模板的内容在子组件作用域内编译。
- 除非子组件模板包含至少一个 <slot> 插口，否则父组件的内容将会被丢弃。当子组件模板只有一个没有属性的 slot 时，父组件整个内容片段将插入到 slot 所在的 DOM 位置，并替换掉 slot 标签本身。
- 在有具名slot的情况下，仍然可以有一个匿名 slot ，它是默认 slot ，作为找不到匹配的内容片段的备用插槽。如果没有默认的 slot ，这些找不到匹配的内容片段将被抛弃。
- 作用域插槽：用作使用一个（能够传递数据到）可重用模板替换已渲染元素。
- 通过使用保留的 <component> 元素，动态地绑定到它的 is 特性，我们让多个组件可以使用同一个挂载点，并动态切换。
- 如果把切换出去的组件保留在内存中，可以保留它的状态或避免重新渲染。为此可以添加一个 keep-alive 指令参数。
```html
<keep-alive>
    <component :is="currentView">
        <!-- 非活动组件将被缓存！ -->
    </component>
</keep-alive>
```
- Vue 组件的 API 来自三部分 - props, events 和 slots ：
    * Props 允许外部环境传递数据给组件;
    * Events 允许组件触发外部环境的副作用;
    * Slots 允许外部环境将额外的内容组合在组件中。
- 如果想要在 JavaScript 中直接访问子组件，可以使用 ref 为子组件指定一个索引 ID，通过 parent.$refs.refID 来引用。
- $refs 只在组件渲染完成后才填充，并且它是非响应式的。它仅仅作为一个直接访问子组件的应急方案——应当避免在模版或计算属性中使用 $refs 。
- 异步组件。
- 当注册组件（或者 props）时，可以使用 kebab-case ，camelCase ，或 TitleCase 命名法。
- 在 HTML 模版中，请使用 kebab-case 形式。
- 在使用字符窜模板时，没有这个限制，以上三种命名方式都可以使用。
- 如果组件未经 slot 元素传递内容，你甚至可以在组件名后使用 / 使其自闭合。当然，这只在字符串模版中有效。因为自闭的自定义元素是无效的 HTML ，浏览器原生的解析器也无法识别它。
- 命名约定总结：TitleCase 是最常用的声明规范；kebab-case是最常用的使用规范。
- 组件在它的模板内可以递归地调用自己，不过，只有当它有 name 选项时才可以。当利用Vue.component全局注册了一个组件, 全局的ID作为组件的 name 选项，被自动设置。
- 出现循环引用的两个组件，当使用Vue.component将这两个组件注册为全局组件的时候，框架会自动为你解决这个矛盾。
- 如果不是注册为全局组件，那么解决办法是：在主组件的 beforeCreate 生命周期钩子中去注册引起循环引用矛盾的子组件。
- 如果子组件有 inline-template 特性，组件将把它的内容当作它的模板，而不是把它当作分发内容。但是 inline-template 让模板的作用域难以理解。最佳实践是使用 template 选项在组件内定义模板或者在 .vue 文件中使用 template 元素。
- 尽管在 Vue 中渲染 HTML 很快，不过当组件中包含大量静态内容时，可以考虑使用 v-once 以确保组件只被计算一次，然后将渲染结果缓存起来。
