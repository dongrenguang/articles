# 安装
- 仅支持IE8（不含）以上的浏览器，因为使用了ECMAScript 5的特性。
- 有两种构建方式，独立构建和运行构建。它们的区别在于前者包含模板编译器而后者不包含。模板编译器的职责是将模板字符串编译为纯 JavaScript 的渲染函数。如果你想要在组件中使用 template 选项，你就需要编译器。
- 独立构建包含模板编译器并支持 template 选项。 它也依赖于浏览器的接口的存在，所以你不能使用它来为服务器端渲染。
- 运行时构建不包含模板编译器，因此不支持 template 选项，只能用 render 选项，但即使使用运行时构建，在单文件组件中也依然可以写模板，因为单文件组件的模板会在构建时预编译为 render 函数。运行时构建比独立构建要轻量30%。默认 NPM 包导出的是 运行时 构建。
- 运行时构建的是完全兼容 CSP（内容安全策略）的；独立的构建取决于该功能编译模板，所以无法使用这些环境。
- UMD版：可以在浏览器中直接通过script标签引用；CommonJS版：供老版本的模块打包器（browserify或webpack 1）使用；ES Module版：供现代化的模块打包器使用（Webpack 2或Gulp）。

# 介绍
- Vue 还提供了 v-model 指令，它能轻松实现表单输入和应用状态之间的双向绑定。


# Vue实例
- 不要在实例属性或者回调函数中（如 vm.$watch('a', newVal => this.myMethod())）使用箭头函数。
- 实例的生命周期：beforeCreate、created、beforeMount、mounted、beforeUpdate、updated、beforeDestroy、destroyed。

# 模板语法

# 计算属性与监视器
- 计算属性会根据他们所依赖的属性进行缓存，而方法则是每次都会执行运算。
- computed getter、setter。
- watch监视器在进行异步或者是耗时操作的时候会很有用。

# Class与Style绑定
- 对象、数组扩展。
- 组件的class会作用域组件的根节点，并且不会覆盖根节点原有的class。
- 内联样式：对象、数组、自动前缀、多个值。

# 条件渲染
- 但是如果我们想切换多个元素呢？此时我们可以把一个 template 元素当做包装元素，并在上面使用 v-if。最终的渲染结果不会包含 template 元素。
- v-show指令：总是被渲染并保存在DOM中，不可与 template 、v-else 同用。
- v-if 是“真正的”条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。
- v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。
- 相比之下， v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。
- 一般来说， v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件不太可能改变，则使用 v-if 较好。

# 列表渲染
- v-for的优先级高于v-if。

# 事件处理器
- v-on:click="handlerName/handlerName(args)"，即可以是处理函数名，也可以直接调用处理函数（内联处理函数）。
- 事件修饰符：.stop, .prevent, .capture, .self, .once
- 只有once修饰符可以同时使用在原生DOM事件和Vue组件事件上，其他的只能作用在原生DOM事件上。
- 按键修饰符、修饰按键、鼠标按键修饰符。
- Vue这样在DOM上添加事件监听的做法违背了关注点分离的传统观念？不会。所有的 Vue.js 事件处理方法和表达式都严格绑定在当前视图的 ViewModel 上，它不会导致任何维护上的困难。
- 使用 v-on 有几个好处：
    * 扫一眼 HTML 模板便能轻松定位在 JavaScript 代码里对应的方法。
    * 因为你无须在 JavaScript 里手动绑定事件，你的 ViewModel 代码可以是非常纯粹的逻辑，和 DOM 完全解耦，更易于测试。
    * 当一个 ViewModel 被销毁时，所有的事件处理器都会自动被删除。你无须担心如何自己清理它们。

# 表单控件绑定
- v-model并不会在 IME（比如：中文、日文） 构成中得到更新，除非自己使用input事件。
- 修饰符：
    * .lazy：在默认情况下， v-model 在 input 事件中同步输入框的值与数据 (除了 上述 IME 部分)，但你可以添加一个修饰符 lazy ，从而转变为在 change 事件中同步。
    * .number：自动将用户的输入值转为 Number 类型。
    * .trim：自动过滤用户输入的首尾空格。
